Set-Location "C:\Users\OEM\proyectos_gito\test2\original_performance_takehome"
claude -p "Continua optimización, cierra la anterior tarea a ver que sale y luego sigue incluye esta idea y dale prioridad: Actúa como ingeniero de rendimiento experto en este simulador VLIW/SIMD (ver problem.py). Objetivo: bajar ciclos hacia ~1000 sin cambiar bit-exactness.  Hecho clave: VLEN=8, valu tiene 6 slots/ciclo, y existe valu:multiply_add que hace 8 lanes en 1 slot. problem.py define HASH_STAGES; NO se puede cambiar el resultado del hash, pero sí reescribir algebraicamente. Tarea principal: Reescribe los stages del hash que son (a + C) + (a << k) como a*(1+2^k) + C usando valu:multiply_add. En concreto, usa estas equivalencias mod 2^32: - stage0: (a + 0x7ED55D16) + (a << 12)  =>  a*4097 + 0x7ED55D16 - stage2: (a + 0x165667B1) + (a << 5)   =>  a*33   + 0x165667B1 - stage4: (a + 0xFD7046C5) + (a << 3)   =>  a*9    +0xFD7046C5 Implementa esto en perf_takehome.py (KernelBuilder): - Pre-broadcast vectores constantes: mul4097, mul33, mul9, y C0/C2/C4. - Sustituye en build_hash... esas partes por valu:multiply_add. - Mantén los otros stages idénticos. Requisitos: - Bit-exactness total on tests existentes.  - Re-dumpea ASM y añade comentarios:   - # HASH STAGE 0 MAD (a*4097 + C0)   - # HASH STAGE 2 MAD (a*33 + C2)   - # HASH STAGE 4 MAD (a*9 + C4)   - Indica qué registros contienen a, mul, C. Entrega: - Diff claro. - Tabla <antes vs después> con conteo de valu ops, multiply_add count, ciclos. - Explica por qué la equivalencia es correcta mod 2^32. Guarda estado antes de preguntar porque esto se ejecutará en una tarea programada y no estaré para responderte." --permission-mode acceptEdits > resultado.log 2>&1